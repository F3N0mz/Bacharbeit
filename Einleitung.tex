\section{Introduction}
\subsection{Problem Definition and Motivation}
The main goal of this project is to explore the possibilities of developing such a device that can be mass produced in a decentralized way using conventional tools (3D printing) and at the same time be widely available due to the low manufacturing costs. The question is whether such a device can exist at all. While there are already ready-made solutions on the market, they are not cheap and lack certain features that are present in the prototype in question, be it the lack of remote controls, the lack of flexible scheduling or the lack of a pill disposal system.

\subsection{Goals and Approach}
   The aim of this project is to develop a device that makes it easier for people with motor or mental disabilities to access their medication. This is to be achieved through automation, ease of use and ergonomics. A working prototype of this device will be developed as part of this project. Here are the initial requirements for this project:
   \begin{enumerate}
   	
   	\item The device should contain 21 chambers, 3 for each day of the week. This would be the default setting, but the schedule could also be configured to dispense pills either twice or once a day. In this case, the 21-chamber system does not correspond exactly to the 1-week dispensing time. The dispensing information would be available to the caregiver
   	\item The device should include a pill disposal system. The purpose of this system is to store the unused pills for safety reasons, to prevent accidental overdosing on previously unused pills and to enable monitoring of unused pills. Therefore, this system is also divided into 21 functional chambers.
   	\item The device will have a companion app. This is an Android-based application that the caregiver can use to configure, monitor and adjust the device.
\end{enumerate}
 As this project involves the development of a prototype, activities such as marketing, certification and industrial mass production are not part of the project.
User testing is also not part of this project, as it requires the production of several devices, the collection of test subjects (i.e. establishing contacts with hospitals, nursing homes, etc.) and the statistical analysis of this data.

All of these are obviously necessary next steps after the development of the prototype, but for this project they are out of the ordinary.
\newpage
\subsection{Structure and Organization of the Work}
This project is divided into several major steps:
\begin{enumerate}
	\item{\textbf{Design and Development of the Body}}
	
	This is the first task: developing the basic structure. At the end of this step, a complete device should be brought into shape. We will look at the different options for developing the structure, discuss their pros and cons and choose the most suitable one for the next step.
	\item{\textbf{Construction and 3D-Printing of the Design}}
	
	This is the step where our design takes on a physical form. This is the prototyping step where we iteratively develop the device to make sure the design works. This is also the step where the material and mechanical properties of our device are our biggest concern. At the end of this step, the device is functional but not yet configurable. This means that it will be able to rotate one chamber at a time.
	\item{\textbf{Development of the Android APP}}
	
	This step is similar to steps 1 and 2, but for an Android app. We design and develop the template for the app, which can then be filled with functions. In this step, we will also determine which functions the microcontroller on our device must output to the app.
	At the end of this step, we would have a working device and an app, but they are not yet connected, which brings us to the next step.
	\item{\textbf{\textbf{Development of the interface between the device and the app}}}
	This is the final step where everything comes together. The device will communicate with the Android app. It will be able to send (usage statistics, current time, time until next delivery, etc.) and receive (configuration settings, forced delivery command, etc.) information.
\end{enumerate}
The table contains more detailed and precise steps to be taken during this project. Please note that it has been expanded and therefore includes more steps. This means that several steps from the table below are combined into one step from the list above. More specifically, steps 1.0 and 2.0 belong to the \hyperref[sec:Bodydesign]{Design and development of the Body} section, and steps 3.0 and 4.0 belong to the \hyperref[sec:3DPrint]{Construction and 3D-Print of Design} section.
\newpage
\begin{table}[h!]
	\centering
	\small
	\begin{tabular}{|p{3cm}|p{4cm}|p{4cm}|p{4cm}|}
	\hline
	\textbf{Work Package} & \textbf{Input} & \textbf{Activity} & \textbf{Goal} \\
	\hline
	1.0 Initialization & Definition of the precise project requirements, identification of the target audience, execution of the bureaucratic process, definition of the project scope. & Communication with stakeholders & Clearly formulated objective, structured development plan. \\
	\hline
	2.0 Physical Requirements & Requirements for the device's physical properties: materials, mechanisms, size, robustness requirements, ergonomics. & Analysis of the target audience and communication with stakeholders. & Definition of the boundaries for the proposed designs. \\
	\hline
	3.0 3D Printing and Construction of a Functional Prototype & Requirements for the materials used, 3D models of the prototype. & Adapting the models for 3D printing, printing the prototypes. & Physically existing device with all functional features. \\
	\hline
	4.0 Implementation of the Delivery System & Constraints from the previous step, ideas for implementation, feasibility of different approaches. & Defining and finalizing a 3D model of the delivery system, 3D design, optional 3D printing of a prototype. & Functional delivery mechanism. \\
	\hline
	5.0 Implementation of the Control System & Requirements for ergonomics and functionality. & Selecting the microcontroller, connecting the microcontroller to the delivery system, creating skeleton functions for the required device features. & Delivery system and control system are interconnected and can be programmed, making the delivery system controllable. \\
	\hline
	6.0 Programming the Remote App & Requirements for the remote app's functionality. & Programming the app (in a high-level programming language). & Application capable of controlling the device over a wireless network. \\
	\hline
	7.0 Programming the Control System & Skeleton functions implemented in the previous steps. & Programming the microcontroller. & The device functions correctly. \\
	\hline
\end{tabular}
	\caption{Project planning table}
	\label{tab:projektplanung}
\end{table}
\newpage
\subsection{Tools and Technologies}
For each step there is a different toolset that will be covered here and then mentioned in the chapter of the particular step if necessity arises. Here are the tools that have been used:

\begin{enumerate}
	\item\textbf{Organisation and Project Management}
	\begin{itemize}
		\item\textbf{GitHub}
		
		Is a version control tool that has been used for bug-fixing, change tracking and logging of the work done. It is used extensively for \hyperref[sec:FrontenddDev]{Frontend} and \hyperref[sec:Backenddev]{Backend} development steps. It is also used to synchronize work from different machines. The project is organized in such a way, that source code for Microcontroller, Android App are all within the same repository.
		\item\textbf{AI Tools}
		\newline These tools are used mostly for troubleshooting and debugging. The process is usually this: When there is an issue that is hard to resolve, the description of the problem and all relevant information is then fed into all 3 of the used Language Models, the resulting solution is usually not something taken verbatim from one, but rather an inspiration to create an own solution based on suggestions gathered from all models. This is done so because these models can be confidently incorrect at times, which, if their advice is taken without understanding, can lead to a deeper level of confusion. It will also be mentioned in the work whenever AI was used to generate solution. 
		
		These three are used together in a way described earlier:
		\newline - \textbf{OpenAI ChatGPT o3}
		\newline - \textbf{Google Gemini 2.5 Pro + AI Studio}
		\newline - \textbf{Deepseek R1}
		\newline \textbf{GitHub Copilot} is integrated within \ac{VSCode} as a plugin. It is sparingly used whenever there are smaller issues, mostly syntax errors to be fixed, as unlike the three models mentioned above it is not a thinking model.
		
	\end{itemize}
	\item\textbf{3D Model Prototyping and Design}
	\begin{itemize}
		\item\textbf{Fusion 360} was the primary \ac{CAD} software used for all stages of 3D modeling. It is the main and only tool used for Prototyping  \hyperref[sec:Bodydesign]{Earlier Sketches} and creating \hyperref[sec:3DPrint]{3D models} of the finalized prototype. Unlike other 3D-Modeling software that relies primarily on meshes (Blender, 3DMax), Fusion 360 Uses parametric design which is more precise, with further slicing for 3D-Printing (further facilitated by built-in export to .stl feature) and contains a wide toolset of analytical features (such as Interference, Center of Mass and Section Analysis which were used extensively). Its parametric nature also allows easy adjustment of dimensions of components whenever an overlap between them happens.
		
		\item\textbf{PrusaSlicer} This software is used as an intermediary step between a 3D-model and 3D-printer. Since printers require a set of commands to execute and a .stl is a geometry data, there needs to be an interpreter software which would translate this data into an instruction set (G-Code, although PrusaSlicer has a very convenient feature of transferring this code directly to the printer if computer with the slicer and 3D-Printer are connected to the internet). All of the prints have been done with the default built in template for Prusa MK4S called \textbf{0.20mm STRUCTURAL}. Some models required support material to be added and since original template doesn't have them enabled (either for autogeneration or for printing) this template would then be adjusted to include printing supports.
	\end{itemize}
	\item\textbf{Frontend Development}
	\begin{itemize}
		
		\item \textbf{Android Development Studio + Kotlin} This combination is a industry standard in Android development. Google has established that Kotlin is preferred language for developing an Android apps \cite{googleIO2019Kotlin}. 
		
		\textbf{Android Development Studio} \ac{IDE} is a joint project of Google and JetBrains, an innovative \ac{IDE} development company. it has many powerful features such as Previews, Device Emulators, Layout Editor and Gradle Build System. These features have alleviated the development process.
		
		\textbf{Kotlin} was chosen because an alternative would be Java, which is not personally preferred development language. Besides being industry standard, Kotlin has very easy-to-understand syntax, \textit{Null-Safety} (a feature of the language, which prevents certain variables to have a null values i.e. value, the pointer of which doesn't have an address), that prevents very common Null-pointer exception runtime errors and also google's official trainings and tutorials which were essential in learning the language. 
	\end{itemize}
	\item\textbf{Backend Development}
	\begin{itemize}
		
		\item \textbf{VSCode + Platform.io + C++} Similar to the Frontend development step, this is also quite common choice for programming. \ac{VSCode} offers a wide variety of plugins, due to being open source, and Platform.io is one of them. 
		
		\textbf{VSCode} is chosen mostly because of ease of use and flexibility. It is Open-Source, therefore there has been a huge community effort to develop plugins and also one can adjust almost every component of the editor as one sees fit, for example by creating and running custom scripts.
		
		\textbf{Platform.io} has many important features, such as Microcontroller templates, built-in C++ and Arduino libraries, Device monitoring (data from connected device can be logged into terminal) and Upload of compiled code. As mentioned before, it is a standard for Arduino software development and enjoys a wide support from the community. This is important not only for the development of a device, but also for maintenance of its code in the future, should a project be further expanded.
		
		\textbf{C++} Was chosen because of efficiency, due to being one of the lower-level programming languages, close to hardware, while also being able to abstract away, reducing the need to manually flip bits on the hardware. Furthermore, unlike C, another commonly used language for hardware programming, C++ supports \ac{OOP}, whose features (Incapsulation, Polymorphism, Inheritance) offer aid in programming a device.
		
	\end{itemize}
	
\end{enumerate}